package github

import (
	"fmt"
	"strings"

	cidsdk "github.com/cidverse/cid-sdk-go"
	"github.com/cidverse/cidverseutils/pkg/version"
)

type PublishAction struct {
	Sdk cidsdk.SDKClient
}

type PublishConfig struct {
	GitHubToken string `json:"github_token"  env:"GITHUB_TOKEN"`
}

func (a PublishAction) Execute() (err error) {
	cfg := PublishConfig{}
	ctx, err := a.Sdk.ProjectAction(&cfg)
	if err != nil {
		return err
	}

	// changelog
	changelogFile := cidsdk.JoinPath(ctx.Config.TempDir, "github.changelog")
	downloadChangelogErr := a.Sdk.ArtifactDownload(cidsdk.ArtifactDownloadRequest{
		Type:       "changelog",
		Name:       "github.changelog",
		TargetFile: changelogFile,
	})

	// options
	releaseOpts := []string{"--verify-tag"}
	if downloadChangelogErr == nil { // use changelog generated by pipeline, default to GitHub auto generated release notes if not available
		releaseOpts = append(releaseOpts, fmt.Sprintf("-F %q", changelogFile))
	} else {
		releaseOpts = append(releaseOpts, "--generate-notes")
	}

	// prerelease
	if !version.IsStable(ctx.Env["NCI_COMMIT_REF_NAME"]) {
		releaseOpts = append(releaseOpts, "--prerelease")
	}

	// release artifacts
	artifacts, err := a.Sdk.ArtifactList(cidsdk.ArtifactListRequest{Query: `artifact_type == "binary"`})
	if err != nil {
		return err
	}
	_ = a.Sdk.Log(cidsdk.LogMessageRequest{Level: "info", Message: "searching for artifacts to include in the release", Context: map[string]interface{}{"artifact_count": len(*artifacts)}})
	for _, artifact := range *artifacts {
		targetFile := cidsdk.JoinPath(ctx.Config.TempDir, artifact.Name)
		var dlErr = a.Sdk.ArtifactDownload(cidsdk.ArtifactDownloadRequest{
			ID:         artifact.ID,
			TargetFile: targetFile,
		})
		if dlErr != nil {
			_ = a.Sdk.Log(cidsdk.LogMessageRequest{Level: "warn", Message: "failed to retrieve release artifact", Context: map[string]interface{}{"artifact": fmt.Sprintf("%s-%s", artifact.Module, artifact.Name)}})
			continue
		}

		releaseOpts = append(releaseOpts, fmt.Sprintf("'%s#%s'", targetFile, artifact.Name))
	}

	// create release
	releaseResult, err := a.Sdk.ExecuteCommand(cidsdk.ExecuteCommandRequest{
		Command: fmt.Sprintf(`gh release create %q %s`, ctx.Env["NCI_COMMIT_REF_NAME"], strings.Join(releaseOpts, " ")),
		WorkDir: ctx.ProjectDir,
		Env: map[string]string{
			"GH_TOKEN": ctx.Env["GITHUB_TOKEN"],
		},
	})
	if err != nil {
		return err
	} else if releaseResult.Code != 0 {
		return fmt.Errorf("github release creation failed, exit code %d", releaseResult.Code)
	}

	return nil
}
