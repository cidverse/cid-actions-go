package github

import (
	"fmt"
	"strings"

	cidsdk "github.com/cidverse/cid-sdk-go"
	"github.com/cidverse/cidverseutils/pkg/version"
)

type PublishAction struct {
	Sdk cidsdk.SDKClient
}

type PublishConfig struct {
	GitHubToken string `json:"github_token"  env:"GITHUB_TOKEN"`
}

func (a PublishAction) Execute() (err error) {
	cfg := PublishConfig{}
	ctx, err := a.Sdk.ProjectAction(&cfg)
	if err != nil {
		return err
	}

	// changelog
	changelogFile := cidsdk.JoinPath(ctx.Config.TempDir, "github.changelog")
	downloadChangelogErr := a.Sdk.ArtifactDownload(cidsdk.ArtifactDownloadRequest{
		Type:       "changelog",
		Name:       "github.changelog",
		TargetFile: changelogFile,
	})

	// options
	var releaseOpts []string
	if downloadChangelogErr == nil { // use changelog generated by pipeline, default to GitHub auto generated release notes if not available
		releaseOpts = append(releaseOpts, fmt.Sprintf("-F %q", changelogFile))
	} else {
		releaseOpts = append(releaseOpts, "--generate-notes")
	}

	// prerelease
	if !version.IsStable(ctx.Env["NCI_COMMIT_REF_NAME"]) {
		releaseOpts = append(releaseOpts, "--prerelease")
	}

	// create release
	releaseResult, err := a.Sdk.ExecuteCommand(cidsdk.ExecuteCommandRequest{
		Command: fmt.Sprintf(`gh release create %q %s`, ctx.Env["NCI_COMMIT_REF_NAME"], strings.Join(releaseOpts, " ")),
		WorkDir: ctx.ProjectDir,
		Env: map[string]string{
			"GH_TOKEN": ctx.Env["GITHUB_TOKEN"],
		},
	})
	if err != nil {
		return err
	} else if releaseResult.Code != 0 {
		return fmt.Errorf("github release creation failed, exit code %d", releaseResult.Code)
	}

	return nil
}
